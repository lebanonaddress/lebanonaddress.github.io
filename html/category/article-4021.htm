<!DOCTYPE html>
<html lang="zh-CN">

<head>
       <link rel="canonical" href="https://lebanonaddress.github.io/html/category/article-4021.htm" />
    <!-- basic -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <!-- mobile metas -->
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="viewport" content="initial-scale=1, maximum-scale=1">
    <link rel="icon" href="/assets/addons/xcblog/img/lebanonaddress/favicon.ico" type="image/x-icon"/>
    <!-- site metas -->
    <title>使用feign客户端要使用注解@EnableFeignClients - Lebanon Address</title>
        <!-- bootstrap css -->
    <link rel="stylesheet" type="text/css" href="/assets/addons/xcblog/css/lebanonaddress/bootstrap.min.css">
    <!-- style css -->
    <link rel="stylesheet" type="text/css" href="/assets/addons/xcblog/css/lebanonaddress/style.css">
    <!-- Responsive-->
    <link rel="stylesheet" href="/assets/addons/xcblog/css/lebanonaddress/responsive.css">
    <!-- Scrollbar Custom CSS -->
    <link rel="stylesheet" href="/assets/addons/xcblog/css/lebanonaddress/jquery.mCustomScrollbar.min.css">
    <!-- Tweaks for older IEs-->
    <link rel="stylesheet" href="https://cdn.bootcdn.net/ajax/libs/font-awesome/4.0.3/css/font-awesome.css">
    <!-- fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Open+Sans:wght@400;600;700&display=swap" rel="stylesheet">
    <script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?f480db041fa3a9ffc78a7d6776ae8726";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>
    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3332997411212854"
     crossorigin="anonymous"></script>
</head>

<body>
       <!-- header section start -->
    <div class="header_section">
        <div class="container">
            <nav class="navbar navbar-expand-lg navbar-light bg-light">
                <div class="logo">
                                        <a href="/">Lebanon Address</a>
                                    </div>
                <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
                    <span class="navbar-toggler-icon"></span>
                </button>
                <div class="collapse navbar-collapse" id="navbarSupportedContent">
                    <ul class="navbar-nav ml-auto">
                                                <li class="nav-item">
                            <a class="nav-link" href="/">首页</a>
                        </li>
                                                <li class="nav-item">
                            <a class="nav-link" href="/html/category/">文章分类</a>
                        </li>
                                                <li class="nav-item">
                            <a class="nav-link" href="#">关于</a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link" href="#">联系</a>
                        </li>
                    </ul>
                </div>
            </nav>
        </div>
    </div>
    <!-- header section end -->
      <!-- services section start -->
      <div class="services_section layout_padding">
         <div class="container">
            <div class="row">
               <div class="col-sm-12">
                  <h1 class="services_taital"><span class="about_icon">使用feign客户端要使用注解@EnableFeignClients </h1>
                    <p class="nav-box text-center">
                        <a href="/">首页</a> / <a href="/html/category/">文章分类</span>
                    </p>
               </div>
            </div>
         </div>
      </div>
      <!-- services section end -->
    <!-- about sectuion start -->
    <div class="about_section layout_padding">
        <div class="container">
            <div class="row">
                <div class="col-md-9">
                      				  				  				<div id="content_views" class="htmledit_views"> <p>概述<br /> 在Spring cloud应用中，当我们要使用feign客户端时，一般要做以下三件事情 :</p> <p>1使用注解@EnableFeignClients启用feign客户端；<br /> 示例 :</p> <p>@SpringBootApplication<br /> @EnableFeignClients<br /> public class TestApplication {<!-- --><br /> &nbsp; &nbsp; public static void main(String[] args) {<!-- --><br /> &nbsp; &nbsp; &nbsp; &nbsp; SpringApplication.run(TestApplication.class, args);<br /> &nbsp; &nbsp; }<br /> }</p> <p> 2使用注解@FeignClient 定义feign客户端 ;<br /> 示例 : 该例子定义了一个feign客户端，将远程服务http://test-service/test/echo映射为一个本地Java方法调用。</p> <p>@FeignClient(name = "test-service", path = "/test")<br /> public interface TestService {<!-- --><br /> &nbsp; &nbsp; @RequestMapping(value = "/echo", method = RequestMethod.GET)<br /> &nbsp; &nbsp; TestModel echo(@RequestParam("parameter") String parameter);<br /> }</p> <p> 3使用注解@Autowired使用上面所定义feign的客户端 ；</p> <p>&nbsp; &nbsp; @Autowired<br /> &nbsp; &nbsp; TestService testService;</p> <p>&nbsp; &nbsp; public void run()<br /> &nbsp; &nbsp; {<!-- --><br /> &nbsp; &nbsp; &nbsp; &nbsp; // 这里的使用本地Java API的方式调用远程的Restful接口<br /> &nbsp; &nbsp; &nbsp; &nbsp; TestModel dto = testService.echo("Hello,你好!");<br /> &nbsp; &nbsp; &nbsp; &nbsp; log.info("echo : {}", dto);<br /> &nbsp; &nbsp; &nbsp;}</p> <p> 上面的三个步骤，前两个步骤可以理解为定义feign客户端,第三步是使用所定义的feign客户端。通过调试发现，上面第三步所注入的testService是一个代理对象，如下所示 :</p> <p>testService = {$Proxy66@5502}<br /> &nbsp;&nbsp; &nbsp;"HardCodedTarget(type=TestService, name=test-service, url=http://test-service/test)"<br /> &nbsp;h = {ReflectiveFeign$FeignInvocationHandler@6924}<br /> &nbsp; target = {Target$HardCodedTarget@6930}<br /> &nbsp; dispatch = {LinkedHashMap@6931} &nbsp;size = 1<br /> &nbsp; &nbsp;0 = {LinkedHashMap$Entry@6948}<br /> &nbsp; &nbsp;&nbsp;&nbsp; &nbsp;"public abstract xxx.model.TestModel xxx.service.TestService.echo(java.lang.String)"</p> <p> 该对象会代理客户端完成远程服务方法的调用，那么，该代理对象是如何生成的 ？这篇文章，我们通过源代码分析来回答这些问题。</p> <p>源代码解析<br /> 源代码版本 : spring-cloud-openfeign-core-2.1.0.RELEASE , Spring Cloud Greenwich.RELEASE</p> <p>注解@EnableFeignClients:扫描和注册feign客户端bean定义<br /> 注解@EnableFeignClients告诉框架扫描所有使用注解@FeignClient定义的feign客户端。它又通过注解@Import导入了类FeignClientsRegistrar( feign客户端注册器),如下所示:</p> <p>@EnableFeignClients<br /> &nbsp;&nbsp; &nbsp;=&gt; @Import(FeignClientsRegistrar.class)</p> <p> 那么 FeignClientsRegistrar 又是做什么的呢 ？我们继续。</p> <p>FeignClientsRegistrar : feign客户端注册器<br /> FeignClientsRegistrar实现了接口 ImportBeanDefinitionRegistrar。而ImportBeanDefinitionRegistrar的设计目的，就是被某个实现类实现，配合使用@Configuration注解的使用者配置类，在配置类被处理时，用于额外注册一部分bean定义:</p> <p>对于上面的例子，使用者配置类就是 TestApplication</p> <p>public interface ImportBeanDefinitionRegistrar {<!-- --></p> <p>&nbsp; &nbsp;/**<br /> &nbsp; &nbsp; * Register bean definitions as necessary based on the given annotation metadata of<br /> &nbsp; &nbsp; * the importing @Configuration class.<br /> &nbsp; &nbsp; * 根据使用者配置类的注解元数据注册bean定义<br /> &nbsp; &nbsp; * @param importingClassMetadata 使用者配置类的注解元数据<br /> &nbsp; &nbsp; * @param registry 当前bean定义注册表，一般指当前Spring应用上下文对象，当前Spring容器<br /> &nbsp; &nbsp; */<br /> &nbsp; &nbsp;public void registerBeanDefinitions(<br /> &nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry);</p> <p>}</p> <p> #registerBeanDefinitions – 注册feign客户端配置和feign客户端<br /> 方法FeignClientsRegistrar#registerBeanDefinitions实现如下:</p> <p>&nbsp; &nbsp;@Override<br /> &nbsp; &nbsp;public void registerBeanDefinitions(AnnotationMetadata metadata,BeanDefinitionRegistry registry) {<!-- --><br /> &nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// 注册缺省配置到容器 registry<br /> &nbsp; &nbsp;&nbsp;&nbsp; &nbsp;registerDefaultConfiguration(metadata, registry);<br /> &nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// 注册所发现的各个 feign 客户端到到容器 registry<br /> &nbsp; &nbsp;&nbsp;&nbsp; &nbsp;registerFeignClients(metadata, registry);<br /> &nbsp; &nbsp;}</p> <p> #registerDefaultConfiguration– 注册feign客户端缺省配置<br /> &nbsp;&nbsp; &nbsp;// 注册feign客户端的缺省配置，缺省配置信息来自注解元数据的属性 defaultConfiguration<br /> &nbsp; &nbsp; private void registerDefaultConfiguration(AnnotationMetadata metadata,BeanDefinitionRegistry registry) {<!-- --><br /> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// 获取注解@EnableFeignClients的注解属性<br /> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;Map&lt;String, Object&gt; defaultAttrs = metadata<br /> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;.getAnnotationAttributes(EnableFeignClients.class.getName(), true);</p> <p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;if (defaultAttrs != null &amp;&amp; defaultAttrs.containsKey("defaultConfiguration")) {<!-- --><br /> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;String name;<br /> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// 下面是对所注册的缺省配置的的命名，格式如下 :<br /> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// default.xxx.TestApplication<br /> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;if (metadata.hasEnclosingClass()) {<!-- --><br /> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// &nbsp;针对注解元数据metadata对应一个内部类或者方法返回的方法本地类的情形<br /> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;name = "default." + metadata.getEnclosingClassName();<br /> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;}<br /> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;else {<br /> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// name 举例 : default.xxx.TestApplication<br /> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// 这里 xxx.TestApplication 是注解@EnableFeignClients所在配置类的长名称<br /> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;name = "default." + metadata.getClassName();<br /> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;}<br /> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// 各种信息准备就绪，现在执行注册<br /> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;registerClientConfiguration(registry, name,<br /> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;defaultAttrs.get("defaultConfiguration"));<br /> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;}<br /> &nbsp;&nbsp; &nbsp;}</p> <p> #registerDefaultConfiguration方法最终注册客户端缺省配置的动作交给方法#registerClientConfiguration执行。</p> <p>#registerClientConfiguration – 注册feign客户端配置<br /> &nbsp; &nbsp; // 将指定feign客户端配置configuration作为一个bean定义注册到容器：<br /> &nbsp; &nbsp; // bean 定义对象类型 : GenericBeanDefinition<br /> &nbsp; &nbsp; // bean class : FeignClientSpecification<br /> &nbsp; &nbsp; // bean name : default.xxx.TestApplication.FeignClientSpecification (缺省配置)<br /> &nbsp; &nbsp; // bean name : test-service.FeignClientSpecification (针对某个feign client 的配置)<br /> &nbsp;&nbsp; &nbsp;private void registerClientConfiguration(BeanDefinitionRegistry registry, Object name,<br /> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;Object configuration) {<!-- --><br /> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;BeanDefinitionBuilder builder = BeanDefinitionBuilder<br /> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;.genericBeanDefinition(FeignClientSpecification.class);<br /> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// 设置构造函数参数<br /> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;builder.addConstructorArgValue(name);<br /> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;builder.addConstructorArgValue(configuration);<br /> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// 从bean定义构建器构造bean定义并注册到容器<br /> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;registry.registerBeanDefinition(<br /> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;name + "." + FeignClientSpecification.class.getSimpleName(),<br /> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;builder.getBeanDefinition());<br /> &nbsp;&nbsp; &nbsp;}</p> <p> #registerClientConfiguration方法用于注册一个feign客户端配置bean,可以用于注册针对所有feign客户端的缺省配置的注册，也可以用于针对每个feign客户端的专有配置的注册。</p> <p>针对所有feign客户端的缺省配置的bean名称类似于 : default.xxx.TestApplication.FeignClientSpecification，<br /> 针对某个名称为test-service的feign客户端的配置的bean名称类似于:test-service.FeignClientSpecification。</p> <p>#registerFeignClients – 注册各个feign客户端及其配置<br /> &nbsp;&nbsp; &nbsp;// 参数 metadata : 注解@EnableFeignClients所在配置类的注解元数据<br /> &nbsp;&nbsp; &nbsp;public void registerFeignClients(AnnotationMetadata metadata,BeanDefinitionRegistry registry) {<!-- --><br /> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// 定义一个基于classpath的组件扫描器，它会根据指定的扫描位置和@EnableFeignClients注解属性<br /> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// 找出开发人员定义的所有feign客户端，也就是那些使用了注解@FeignClient的所有接口定义<br /> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;ClassPathScanningCandidateComponentProvider scanner = getScanner();<br /> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;scanner.setResourceLoader(this.resourceLoader);</p> <p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;Set&lt;String&gt; basePackages;</p> <p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// attrs 用于表示注解@EnableFeignClients所在配置类的注解元数据中注解@EnableFeignClients<br /> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// 的部分<br /> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;Map&lt;String, Object&gt; attrs = metadata<br /> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;.getAnnotationAttributes(EnableFeignClients.class.getName());<br /> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;AnnotationTypeFilter annotationTypeFilter = new AnnotationTypeFilter(<br /> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;FeignClient.class);<br /> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;final Class&lt;?&gt;[] clients = attrs == null ? null<br /> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;: (Class&lt;?&gt;[]) attrs.get("clients");<br /> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;if (clients == null || clients.length == 0) {<!-- --><br /> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;// @EnableFeignClients 中没有指定 clients 属性的情况<br /> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;scanner.addIncludeFilter(annotationTypeFilter);<br /> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;basePackages = getBasePackages(metadata);<br /> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;}<br /> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;else {<!-- --><br /> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;// @EnableFeignClients 中指定了 clients 属性的情况<br /> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;final Set&lt;String&gt; clientClasses = new HashSet&lt;&gt;();<br /> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;basePackages = new HashSet&lt;&gt;();<br /> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;for (Class&lt;?&gt; clazz : clients) {<!-- --><br /> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;basePackages.add(ClassUtils.getPackageName(clazz));<br /> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;clientClasses.add(clazz.getCanonicalName());<br /> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;}<br /> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;AbstractClassTestingTypeFilter filter = new AbstractClassTestingTypeFilter() {<!-- --><br /> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;@Override<br /> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;protected boolean match(ClassMetadata metadata) {<!-- --><br /> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;String cleaned = metadata.getClassName().replaceAll("\\$", ".");<br /> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;return clientClasses.contains(cleaned);<br /> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;}<br /> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;};<br /> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;scanner.addIncludeFilter(<br /> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;new AllTypeFilter(Arrays.asList(filter, annotationTypeFilter)));<br /> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;}</p> <p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// 使用 scanner 扫描每一个 basePackage, 获取其中的 feign 客户端定义，<br /> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// 也就是 @FeignClient 定义的那些接口<br /> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;for (String basePackage : basePackages) {<!-- --><br /> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;Set&lt;BeanDefinition&gt; candidateComponents = scanner<br /> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;.findCandidateComponents(basePackage);<br /> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;for (BeanDefinition candidateComponent : candidateComponents) {<!-- --><br /> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;if (candidateComponent instanceof AnnotatedBeanDefinition) {<!-- --><br /> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// verify annotated class is an interface<br /> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;AnnotatedBeanDefinition beanDefinition = (AnnotatedBeanDefinition) candidateComponent;<br /> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;AnnotationMetadata annotationMetadata = beanDefinition.getMetadata();<br /> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;Assert.isTrue(annotationMetadata.isInterface(),<br /> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;"@FeignClient can only be specified on an interface");</p> <p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// 获取所定义的feign客户端接口上的注解@FeignClient属性<br /> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;Map&lt;String, Object&gt; attributes = annotationMetadata<br /> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;.getAnnotationAttributes(<br /> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;FeignClient.class.getCanonicalName());</p> <p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;String name = getClientName(attributes);<br /> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// 将所定义的feign客户端上的配置属性作为一个bean注册到容器<br /> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// 此方法的逻辑我们上面已经分析过<br /> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;registerClientConfiguration(registry, name,<br /> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;attributes.get("configuration"));</p> <p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// 将所定义的feign客户端作为一个bean注册到容器：<br /> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// bean 定义类型 : GenericBeanDefinition<br /> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// &nbsp;bean class : FeignClientFactoryBean<br /> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// &nbsp;autowire 模式 : 根据类型绑定<br /> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// @FeignClient注解中的url,path,fallback等属性会设置为bean定义的属性<br /> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;registerFeignClient(registry, annotationMetadata, attributes);<br /> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;}<br /> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;}<br /> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;}<br /> &nbsp;&nbsp; &nbsp;}</p> <p>&nbsp;&nbsp; &nbsp;// 辅助工具类，从@EnableFeignClients注解属性中获取basePackages属性:<br /> &nbsp;&nbsp; &nbsp;// 参考以下@EnableFeignClients注解属性 :<br /> &nbsp;&nbsp; &nbsp;// 1. value<br /> &nbsp;&nbsp; &nbsp;// 2. basePackages<br /> &nbsp;&nbsp; &nbsp;// 3. basePackageClasses<br /> &nbsp;&nbsp; &nbsp;// 4. 配置类所在的包<br /> &nbsp;&nbsp; &nbsp;// 参数 importingClassMetadata : 使用注解@EnableFeignClients的配置类的元数据<br /> &nbsp;&nbsp; &nbsp;protected Set&lt;String&gt; getBasePackages(AnnotationMetadata importingClassMetadata) {<!-- --><br /> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// 注解@EnableFeignClients的属性<br /> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;Map&lt;String, Object&gt; attributes = importingClassMetadata<br /> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;.getAnnotationAttributes(EnableFeignClients.class.getCanonicalName());</p> <p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;Set&lt;String&gt; basePackages = new HashSet&lt;&gt;();<br /> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;for (String pkg : (String[]) attributes.get("value")) {<!-- --><br /> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;if (StringUtils.hasText(pkg)) {<!-- --><br /> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;basePackages.add(pkg);<br /> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;}<br /> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;}<br /> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;for (String pkg : (String[]) attributes.get("basePackages")) {<!-- --><br /> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;if (StringUtils.hasText(pkg)) {<!-- --><br /> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;basePackages.add(pkg);<br /> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;}<br /> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;}<br /> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;for (Class&lt;?&gt; clazz : (Class[]) attributes.get("basePackageClasses")) {<!-- --><br /> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;basePackages.add(ClassUtils.getPackageName(clazz));<br /> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;}</p> <p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;if (basePackages.isEmpty()) {<!-- --><br /> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;basePackages.add(<br /> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;ClassUtils.getPackageName(importingClassMetadata.getClassName()));<br /> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;}<br /> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;return basePackages;<br /> &nbsp;&nbsp; &nbsp;}</p> <p> #registerFeignClients 最终注册feign客户端配置的动作交给#registerClientConfiguration完成，而注册feign客户端的动作交给#registerFeignClient方法完成。</p> <p>#registerFeignClient – 注册一个feign客户端<br /> &nbsp;&nbsp; &nbsp;// 将所定义的feign客户端作为一个bean注册到容器：<br /> &nbsp;&nbsp; &nbsp;// bean 定义类型 : GenericBeanDefinition<br /> &nbsp;&nbsp; &nbsp;// &nbsp;bean class : FeignClientFactoryBean -- 这是一个工厂bean，而不是最终bean实例的class<br /> &nbsp;&nbsp; &nbsp;// &nbsp;autowire 模式 : 根据类型绑定<br /> &nbsp;&nbsp; &nbsp;// @FeignClient注解中的url,path,fallback等属性会设置为bean定义的属性<br /> &nbsp;&nbsp; &nbsp;// 参数 registry : Spring 容器<br /> &nbsp;&nbsp; &nbsp;// 参数 annotationMetadata : @FeignClient所注解的接口上的注解元数据<br /> &nbsp;&nbsp; &nbsp;// 参数 attributes : @FeignClient 注解属性信息<br /> &nbsp;&nbsp; &nbsp;private void registerFeignClient(BeanDefinitionRegistry registry,<br /> &nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;AnnotationMetadata annotationMetadata, Map&lt;String, Object&gt; attributes) {<!-- --><br /> &nbsp; &nbsp;&nbsp;&nbsp; &nbsp;String className = annotationMetadata.getClassName();<br /> &nbsp; &nbsp;&nbsp;&nbsp; &nbsp;BeanDefinitionBuilder definition = BeanDefinitionBuilder<br /> &nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;.genericBeanDefinition(FeignClientFactoryBean.class);<br /> &nbsp; &nbsp;&nbsp;&nbsp; &nbsp;validate(attributes);<br /> &nbsp; &nbsp;&nbsp;&nbsp; &nbsp;definition.addPropertyValue("url", getUrl(attributes));<br /> &nbsp; &nbsp;&nbsp;&nbsp; &nbsp;definition.addPropertyValue("path", getPath(attributes));<br /> &nbsp; &nbsp;&nbsp;&nbsp; &nbsp;String name = getName(attributes);<br /> &nbsp; &nbsp;&nbsp;&nbsp; &nbsp;definition.addPropertyValue("name", name);<br /> &nbsp; &nbsp;&nbsp;&nbsp; &nbsp;definition.addPropertyValue("type", className);<br /> &nbsp; &nbsp;&nbsp;&nbsp; &nbsp;definition.addPropertyValue("decode404", attributes.get("decode404"));<br /> &nbsp; &nbsp;&nbsp;&nbsp; &nbsp;definition.addPropertyValue("fallback", attributes.get("fallback"));<br /> &nbsp; &nbsp;&nbsp;&nbsp; &nbsp;definition.addPropertyValue("fallbackFactory", attributes.get("fallbackFactory"));<br /> &nbsp; &nbsp;&nbsp;&nbsp; &nbsp;definition.setAutowireMode(AbstractBeanDefinition.AUTOWIRE_BY_TYPE);</p> <p>&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;String alias = name + "FeignClient";<br /> &nbsp; &nbsp;&nbsp;&nbsp; &nbsp;AbstractBeanDefinition beanDefinition = definition.getBeanDefinition();</p> <p>&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;boolean primary = (Boolean)attributes.get("primary"); // has a default, won't be null</p> <p>&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;beanDefinition.setPrimary(primary);</p> <p>&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;String qualifier = getQualifier(attributes);<br /> &nbsp; &nbsp;&nbsp;&nbsp; &nbsp;if (StringUtils.hasText(qualifier)) {<!-- --><br /> &nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;alias = qualifier;<br /> &nbsp; &nbsp;&nbsp;&nbsp; &nbsp;}</p> <p>&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;BeanDefinitionHolder holder = new BeanDefinitionHolder(beanDefinition, className,<br /> &nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;new String[] { alias });<br /> &nbsp; &nbsp;&nbsp;&nbsp; &nbsp;BeanDefinitionReaderUtils.registerBeanDefinition(holder, registry);<br /> &nbsp; &nbsp;}</p> <p> 从上面的代码分析可知，FeignClientsRegistrar的主要作用如下 :</p> <p>注册缺省feign客户端配置bean定义；<br /> 对于每个@FeignClient注解的feign客户端定义 :<br /> 注册一个针对该feign客户端的配置bean定义；<br /> 注册该feign客户端bean定义,指定生成bean实例采用工厂类FeignClientFactoryBean;<br /> 而且，上述功能实现在类方法FeignClientsRegistrar#registerBeanDefinitions中，这是接口ImportBeanDefinitionRegistrar所定义的方法。该方法会在@EnableFeignClients注解被处理时执行。具体的执行时调用栈如下所示：</p> <p>&nbsp; &nbsp; AbstractApplicationContext#invokeBeanFactoryPostProcessors<br /> &nbsp; &nbsp; =&gt; PostProcessorRegistrationDelegate#invokeBeanFactoryPostProcessors<br /> &nbsp; &nbsp; =&gt; foreach BeanDefinitionRegistryPostProcessor : #postProcessBeanDefinitionRegistry<br /> &nbsp; &nbsp; =&gt; ConfigurationClassPostProcessor#postProcessBeanDefinitionRegistry<br /> &nbsp; &nbsp; =&gt; #processConfigBeanDefinitions<br /> &nbsp; &nbsp; =&gt; ConfigurationClassBeanDefinitionReader#loadBeanDefinitions<br /> &nbsp; &nbsp; =&gt; foreach ConfigurationClass : #loadBeanDefinitionsForConfigurationClass<br /> &nbsp; &nbsp; =&gt; #loadBeanDefinitionsFromRegistrars<br /> &nbsp; &nbsp; =&gt; foreach ImportBeanDefinitionRegistrar : #registerBeanDefinitions<br /> &nbsp; &nbsp; =&gt; FeignClientsRegistrar#registerBeanDefinitions</p> <p> FeignClientFactoryBean生成feign客户端代理对象<br /> 基于上面的分析，我们可以得知，开发人员所定义的feign客户端和相关配置会以bean定义的形式注册到bean容器中，这样当使用@Autowired注入一个feign客户端时，容器会使用工厂类FeignClientFactoryBean为其生成一个实例。下面我们来看其具体工作过程。</p> <p>FeignClientFactoryBean#getObject生成feign客户端代理对象<br /> &nbsp; &nbsp; // 该方法由接口FactoryBean约定<br /> &nbsp; &nbsp;&nbsp;&nbsp; &nbsp;@Override<br /> &nbsp;&nbsp; &nbsp;public Object getObject() throws Exception {<!-- --><br /> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;return getTarget();<br /> &nbsp;&nbsp; &nbsp;}</p> <p> &nbsp;&nbsp; &nbsp;&lt;T&gt; T getTarget() {<!-- --><br /> &nbsp; &nbsp; &nbsp; &nbsp; // &nbsp;从应用上下文中获取创建 feign 客户端的上下文对象 FeignContext<br /> &nbsp; &nbsp; &nbsp; &nbsp; // FeignContext 针对每个feign客户端定义会生成一个不同的 AnnotationConfigApplicationContext，<br /> &nbsp; &nbsp; &nbsp; &nbsp; // 这些应用上下文的parent都设置为当前应用的主应用上下文<br /> &nbsp; &nbsp; &nbsp; &nbsp; // 参考 : FeignAutoConfiguration<br /> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;FeignContext context = applicationContext.getBean(FeignContext.class);<br /> &nbsp; &nbsp; &nbsp; &nbsp; // 为目标feign客户端对象构建一个 builder,该builder最终生成的目标feign客户端是一个<br /> &nbsp; &nbsp; &nbsp; &nbsp; // 动态代理，使用 InvocationHandler ： ReflectiveFeign$FeignInvocationHandler<br /> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;Feign.Builder builder = feign(context);</p> <p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;if (!StringUtils.hasText(this.url)) {<!-- --><br /> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;// @FeignClient 属性 url 属性没有指定的情况<br /> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;// 根据属性 name , path 拼装一个 url，<br /> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;// 这种通常是需要在多个服务节点之间进行负载均衡的情况<br /> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;if (!this.name.startsWith("http")) {<!-- --><br /> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;url = "http://" + this.name;<br /> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;}<br /> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;else {<!-- --><br /> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;url = this.name;<br /> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;}<br /> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;// 方法cleanPath()加工属性path，使其以/开头，不以/结尾<br /> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;url += cleanPath();<br /> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;// 这里形成的url格式类似 : &nbsp;http://test-service/test<br /> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;// 其中 test-service 是服务名，不是服务所在节点的IP，主机名或者域名</p> <p> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;// 函数 loadBalance 做如下动作 :<br /> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;// 1. 将builder和一个LoadBalancerFeignClient bean实例关联起来<br /> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;// 2. 使用一个HystrixTargeter将builder和一个 HardCodedTarget bean实例关联起来<br /> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;// 这里 HardCodedTarget 表示对应 url 为 http://test-service/test 的远程服务(可能<br /> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;// 包含多个服务方法)<br /> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;// 3. 生成最终的feign client 实例 : ReflectiveFeign$FeignInvocationHandler 的动态代理对象，<br /> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;// 使用 InvocationHandler ： ReflectiveFeign$FeignInvocationHandler。<br /> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;// 每个远程服务方法会对应到一个@FeignClient注解的接口方法上(依据方法上的注解进行匹配)<br /> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;return (T) loadBalance(builder, context, new HardCodedTarget&lt;&gt;(this.type,<br /> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;this.name, url));<br /> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;}</p> <p> &nbsp; &nbsp; &nbsp; &nbsp; // @FeignClient 属性 url 属性被指定的情况<br /> &nbsp; &nbsp; &nbsp; &nbsp; // 这种通常是明确指出了服务节点的url的情况，实际上不需要负载均衡<br /> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;if (StringUtils.hasText(this.url) &amp;&amp; !this.url.startsWith("http")) {<!-- --><br /> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;this.url = "http://" + this.url;<br /> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;}<br /> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;String url = this.url + cleanPath();<br /> &nbsp; &nbsp; &nbsp; &nbsp; // 将builder和一个LoadBalancerFeignClient bean实例关联起来<br /> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;Client client = getOptional(context, Client.class);<br /> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;if (client != null) {<!-- --><br /> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;if (client instanceof LoadBalancerFeignClient) {<!-- --><br /> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// not load balancing because we have a url,<br /> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// but ribbon is on the classpath, so unwrap<br /> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// 因为指定了明确的服务节点url，所以这里不需要负载均衡，<br /> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// 所以这里尽管client是LoadBalancerFeignClient，所以<br /> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// 实际上可以获取其所代理的对象作为最终的client，<br /> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// 相当于去掉了LoadBalancerFeignClient这层的代理功能<br /> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;client = ((LoadBalancerFeignClient)client).getDelegate();<br /> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;}<br /> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;builder.client(client);<br /> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;}<br /> &nbsp; &nbsp; &nbsp; &nbsp; // 使用一个HystrixTargeter将builder和一个 HardCodedTarget bean实例关联起来<br /> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;Targeter targeter = get(context, Targeter.class);<br /> &nbsp; &nbsp; &nbsp; &nbsp; // 生成最终的feign client 实例 : ReflectiveFeign$FeignInvocationHandler 的动态代理对象，<br /> &nbsp; &nbsp; &nbsp; &nbsp; // 使用 InvocationHandler ： ReflectiveFeign$FeignInvocationHandler。<br /> &nbsp; &nbsp; &nbsp; &nbsp; // 每个远程服务方法会对应到 一个@FeignClient注解的接口方法上(依据方法上的注解进行匹配)<br /> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;return (T) targeter.target(this, builder, context, new HardCodedTarget&lt;&gt;(<br /> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;this.type, this.name, url));<br /> &nbsp;&nbsp; &nbsp;}</p> <p> 方法FeignClientFactoryBean#feign – 创建feign客户端构建器<br /> protected Feign.Builder feign(FeignContext context) {<!-- --><br /> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;FeignLoggerFactory loggerFactory = get(context, FeignLoggerFactory.class);<br /> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;Logger logger = loggerFactory.create(this.type);</p> <p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// 从上下文获取一个 Feign.Builder 上,<br /> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// 并从上下文获得 Encoder, Decoder, Contract 设置到该 builder 上<br /> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;Feign.Builder builder = get(context, Feign.Builder.class)<br /> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// required values<br /> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;.logger(logger)<br /> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;.encoder(get(context, Encoder.class))<br /> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;.decoder(get(context, Decoder.class))<br /> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;.contract(get(context, Contract.class));</p> <p> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// 对 builder 进行其他属性设置<br /> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;configureFeign(context, builder);</p> <p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;return builder;<br /> &nbsp;&nbsp; &nbsp;}</p> <p> 方法FeignClientFactoryBean#loadBalance – 生成具备负载均衡能力的feign客户端<br /> 为feign客户端构建器绑定负载均衡客户端,绑定目标服务端点，并生成最终的feign客户端实例。</p> <p>// 对builder设置负载均衡客户端，绑定到目标服务端点，构建最终的feign客户端对象<br /> protected &lt;T&gt; T loadBalance(Feign.Builder builder, FeignContext context,<br /> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;HardCodedTarget&lt;T&gt; target) {<!-- --><br /> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// 从上下文context获取一个Client，缺省是 LoadBalancerFeignClient<br /> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;Client client = getOptional(context, Client.class);<br /> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;if (client != null) {<!-- --><br /> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// 将client设置到builder上<br /> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;builder.client(client);<br /> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// 从上下文中获取一个 targeter,缺省是一个 HystrixTargeter<br /> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;Targeter targeter = get(context, Targeter.class);<br /> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// 上面获取得到的 targeter 会根据 builder 的类型决定如何将 target<br /> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// 绑定到 builder 并设置有关的其他属性和功能,然后生成最终的feign客户端对象<br /> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;return targeter.target(this, builder, context, target);<br /> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;}</p> <p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;throw new IllegalStateException(<br /> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;"No Feign Client for loadBalancing defined. Did you forget to include " +<br /> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;"spring-cloud-starter-netflix-ribbon?");<br /> &nbsp;&nbsp; &nbsp;}</p> <p> 从上面分析可以看出，缺省情况下，所使用的feign客户端构建器类为Feign.Builder,并且Targeter是一个HystrixTargeter。HystrixTargeter#target方法的参数builder为Feign.Builder时，会直接调用该builder的target方法,如下所示 ：</p> <p>class HystrixTargeter implements Targeter {<!-- --><br /> @Override<br /> &nbsp;&nbsp; &nbsp;public &lt;T&gt; T target(FeignClientFactoryBean factory, Feign.Builder feign, FeignContext context,<br /> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;Target.HardCodedTarget&lt;T&gt; target) {<!-- --><br /> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;if (!(feign instanceof feign.hystrix.HystrixFeign.Builder)) {<!-- --><br /> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;return feign.target(target);<br /> &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;}<br /> &nbsp; &nbsp; &nbsp; &nbsp;// ... 省略其他代码<br /> &nbsp;&nbsp; &nbsp;}<br /> }</p> <p> 接下来再来看Feign.Builder#target是如何工作的:</p> <p>&nbsp; // 执行构建并且创建相应的feign客户端实例<br /> &nbsp; public &lt;T&gt; T target(Target&lt;T&gt; target) {<!-- --><br /> &nbsp; &nbsp; &nbsp; return build().newInstance(target);<br /> &nbsp; &nbsp; }</p> <p> &nbsp; // 构建过程，最终根据各种配置生成一个 ReflectiveFeign 对象<br /> &nbsp; public Feign build() {<!-- --><br /> &nbsp; &nbsp; &nbsp; SynchronousMethodHandler.Factory synchronousMethodHandlerFactory =<br /> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; new SynchronousMethodHandler.Factory(client, retryer, requestInterceptors, logger,<br /> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; logLevel, decode404, closeAfterDecode, propagationPolicy);<br /> &nbsp; &nbsp; &nbsp; ParseHandlersByName handlersByName =<br /> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; new ParseHandlersByName(contract, options, encoder, decoder, queryMapEncoder,<br /> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; errorDecoder, synchronousMethodHandlerFactory);<br /> &nbsp; &nbsp; &nbsp; return new ReflectiveFeign(handlersByName, invocationHandlerFactory, queryMapEncoder);<br /> &nbsp; &nbsp; }<br /> &nbsp; }</p> <p> 然后再看ReflectiveFeign#newInstance方法:</p> <p>&nbsp; // 创建最终的feign客户端实例 : 一个 ReflectiveFeign$FeignInvocationHandler 的动态代理对象<br /> &nbsp; @Override<br /> &nbsp; public &lt;T&gt; T newInstance(Target&lt;T&gt; target) {<!-- --><br /> &nbsp; &nbsp; Map&lt;String, MethodHandler&gt; nameToHandler = targetToHandlersByName.apply(target);<br /> &nbsp; &nbsp; Map&lt;Method, MethodHandler&gt; methodToHandler = new LinkedHashMap&lt;Method, MethodHandler&gt;();<br /> &nbsp; &nbsp; List&lt;DefaultMethodHandler&gt; defaultMethodHandlers = new LinkedList&lt;DefaultMethodHandler&gt;();</p> <p>&nbsp; &nbsp; for (Method method : target.type().getMethods()) {<!-- --><br /> &nbsp; &nbsp; &nbsp; if (method.getDeclaringClass() == Object.class) {<!-- --><br /> &nbsp; &nbsp; &nbsp; &nbsp; continue;<br /> &nbsp; &nbsp; &nbsp; } else if (Util.isDefault(method)) {<!-- --><br /> &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp;// 对于每个缺省方法，使用 DefaultMethodHandler<br /> &nbsp; &nbsp; &nbsp; &nbsp; DefaultMethodHandler handler = new DefaultMethodHandler(method);<br /> &nbsp; &nbsp; &nbsp; &nbsp; defaultMethodHandlers.add(handler);<br /> &nbsp; &nbsp; &nbsp; &nbsp; methodToHandler.put(method, handler);<br /> &nbsp; &nbsp; &nbsp; } else {<!-- --><br /> &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp;// 对于每个对应服务功能端点的方法，缺省使用nameToHandler获取的MethodHandler，缺省是<br /> &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp;// SynchronousMethodHandler<br /> &nbsp; &nbsp; &nbsp; &nbsp; methodToHandler.put(method, nameToHandler.get(Feign.configKey(target.type(), method)));<br /> &nbsp; &nbsp; &nbsp; }<br /> &nbsp; &nbsp; }<br /> &nbsp; &nbsp; // 创建feign客户端实例 ReflectiveFeign$FeignInvocationHandler,<br /> &nbsp; &nbsp; // 该对象包含了上面所创建的methodToHandler，用于对应各个开发者定义的@FeignClient接口方法<br /> &nbsp; &nbsp; InvocationHandler handler = factory.create(target, methodToHandler);<br /> &nbsp; &nbsp; // 创建feign客户端实例的动态代理对象<br /> &nbsp; &nbsp; T proxy = (T) Proxy.newProxyInstance(target.type().getClassLoader(),<br /> &nbsp; &nbsp; &nbsp; &nbsp; new Class&lt;?&gt;[] {target.type()}, handler);</p> <p>&nbsp;&nbsp; &nbsp;// 将缺省方法处理器绑定到feign客户端实例的动态代理对象上<br /> &nbsp; &nbsp; for (DefaultMethodHandler defaultMethodHandler : defaultMethodHandlers) {<!-- --><br /> &nbsp; &nbsp; &nbsp; defaultMethodHandler.bindTo(proxy);<br /> &nbsp; &nbsp; }<br /> &nbsp; &nbsp; return proxy;<br /> &nbsp; }<br /> 从上面的分析我们不难看出，为什么最终注入的testService最终是一个ReflectiveFeign$FeignInvocationHandler动态代理实例了。</p> <p>总结<br /> 从上面的分析可以看出，当我们使用注解@EnableFeignClients 时，相当于启用了feign客户端定义的扫描和注册机制，从而可以发现开发人员通过注解@FeignClient定义的feign客户端，并最终作为bean定义注册到容器中。而通过@Autowired自动装配注解，这些feign客户端会以ReflectiveFeign$FeignInvocationHandler动态代理的形式被注入到使用方。该feign客户端包含了对每个接口方法的处理器MethodHandler,接口缺省方法对应DefaultMethodHandler,服务功能端点方法对应SynchronousMethodHandler。</p> </div> 			
                    <div class="col-md-12 mt-5">
                                                <p>上一个：<a href="/html/category/article-4020.htm">spring schedule 配置多任务动态 cron 【增删启停】</a></p>
                                                <p>下一个：<a href="/html/category/article-4022.htm">java socket read 堵塞问题的解决方法</a></p>
                                            </div>

                                    </div>
                <div class="col-md-3">
                  <div class="panel panel-default">
    <div class="panel-heading">
        <h3 class="panel-title">热门文章</h3>
    </div>
    <div class="panel-body">
        <ul class="p-0 x-0" style="list-style: none;margin: 0;padding: 0;">
                        <li class="py-2"><a href="/html/category/article-6779.htm" title="胶原蛋白肽粉哪个品牌好一点(胶原蛋白肽粉哪个品牌好一点儿)">胶原蛋白肽粉哪个品牌好一点(胶原蛋白肽粉哪个品牌好一点儿)</a></li>
                        <li class="py-2"><a href="/html/category/article-7422.htm" title="晒杨梅干的好吃窍门,让你轻松掌握一下(晒杨梅干的好吃窍门,让你轻松掌握下来)">晒杨梅干的好吃窍门,让你轻松掌握一下(晒杨梅干的好吃窍门,让你轻松掌握下来)</a></li>
                        <li class="py-2"><a href="/html/category/article-7606.htm" title="用电饭锅做小豆饭(小豆饭怎么煮)">用电饭锅做小豆饭(小豆饭怎么煮)</a></li>
                        <li class="py-2"><a href="/html/category/article-7423.htm" title="超级翁婿分集介绍大结局（超级翁婿）满满干货，">超级翁婿分集介绍大结局（超级翁婿）满满干货，</a></li>
                        <li class="py-2"><a href="/html/category/article-6686.htm" title="动物疫苗公司全球（动物疫苗公司10强）">动物疫苗公司全球（动物疫苗公司10强）</a></li>
                        <li class="py-2"><a href="/html/category/article-6916.htm" title="制狗粮的机器设备有哪些（机器制作狗粮的配方大全）">制狗粮的机器设备有哪些（机器制作狗粮的配方大全）</a></li>
                        <li class="py-2"><a href="/html/category/article-7009.htm" title="咸鱼无货源赚钱吗是真的吗（闲鱼无货源赚钱详细教程）">咸鱼无货源赚钱吗是真的吗（闲鱼无货源赚钱详细教程）</a></li>
                        <li class="py-2"><a href="/html/category/article-6733.htm" title="瓷砖旗下品牌大全">瓷砖旗下品牌大全</a></li>
                        <li class="py-2"><a href="/html/category/article-7468.htm" title="动物疫苗价格表图片及价格大全图（动物疫苗多少钱一支）">动物疫苗价格表图片及价格大全图（动物疫苗多少钱一支）</a></li>
                        <li class="py-2"><a href="/html/category/article-7376.htm" title="动物疫苗代理 动物疫苗代理需要什么资质">动物疫苗代理 动物疫苗代理需要什么资质</a></li>
                    </ul>
    </div>
</div>

<div class="panel panel-default">
    <div class="panel-heading">
        <h3 class="panel-title">归纳</h3>
    </div>
    <div class="panel-body">
        <ul class="p-0 x-0" style="list-style: none;margin: 0;padding: 0;">
                        <li class="py-2">
                <h4><span class="badge" style="float: right;">36</span> <a href="/html/date/2024-08/" title="2024-08 归档">2024-08</a></h4>
            </li>
                        <li class="py-2">
                <h4><span class="badge" style="float: right;">62</span> <a href="/html/date/2024-07/" title="2024-07 归档">2024-07</a></h4>
            </li>
                        <li class="py-2">
                <h4><span class="badge" style="float: right;">60</span> <a href="/html/date/2024-06/" title="2024-06 归档">2024-06</a></h4>
            </li>
                        <li class="py-2">
                <h4><span class="badge" style="float: right;">62</span> <a href="/html/date/2024-05/" title="2024-05 归档">2024-05</a></h4>
            </li>
                        <li class="py-2">
                <h4><span class="badge" style="float: right;">60</span> <a href="/html/date/2024-04/" title="2024-04 归档">2024-04</a></h4>
            </li>
                        <li class="py-2">
                <h4><span class="badge" style="float: right;">62</span> <a href="/html/date/2024-03/" title="2024-03 归档">2024-03</a></h4>
            </li>
                        <li class="py-2">
                <h4><span class="badge" style="float: right;">44</span> <a href="/html/date/2024-02/" title="2024-02 归档">2024-02</a></h4>
            </li>
                    </ul>
    </div>
</div>



               </div>
            </div>
        </div>
    </div>
    <!-- about sectuion end -->
        <!-- copyright section start -->
    <div class="copyright_section">
        <div class="container">
            <div class="row">
                <div class="col-sm-12">
                    <p class="copyright_text">
                        Lebanon Address 版权所有
                        <br />
                        Powered by WordPress
                    </p>
                </div>
            </div>
        </div>
    </div>
    <!-- copyright section end -->
    <!-- Javascript files-->
    <script src="/assets/addons/xcblog/js/frontend/lebanonaddress/jquery.min.js"></script>
    <script src="/assets/addons/xcblog/js/frontend/lebanonaddress/popper.min.js"></script>
    <script src="/assets/addons/xcblog/js/frontend/lebanonaddress/bootstrap.bundle.min.js"></script>
    <script src="/assets/addons/xcblog/js/frontend/lebanonaddress/jquery-3.0.0.min.js"></script>
    <script src="/assets/addons/xcblog/js/frontend/lebanonaddress/plugin.js"></script>
    <script>
    $(function() {
        $('.js_to').click(function(){
            var url = $(this).data('url');
            var code = $(this).data('code');
            url += code;

            window.open(url);
        })
    });
    </script>
</body>

</html>